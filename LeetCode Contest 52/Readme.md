# Leetcode-Contest-52
    
[题目传送门](https://leetcode.com/contest/weekly-contest-52/)

当场做的，只过了第一题和第三题，最后将近50分钟都没磕出B。果然还是得学习一个树上递归处理的问题吧。第一题脑残还多交了3发，主要是第一次错的时候没有看图啊，其实看了的话直接写个判断就行了啊，算是LeetCode的题目比CF的题数据容易的一个地方吧。最后发现名次和上次差不多，稍微涨了一点rating有点意外。虽然也没听说LeetCode的rating有啥用，自我满足吧233

## A. Repeated String Match

让你求最少重复A多少次，才能在使得B是A的子串；如果不能，输出-1. 字符串长度1e4

一开始想的就是直接String的find，TLE了一发改成了KMP继续TLE。后来发现数据是就一个字母不一样显然是-1就加了一个-1的特判条件就过了。其实最主要的在于发现：当A的长度比B长的时候，再重复一次就行了，因为再往后重复都是徒劳的，因为只会在第一次重复的时候尾首相接有意义，后面的都是重复的。当然A的长度肯定不能小于B的。因此相当于只要find两次就行了。

## B. Longest Univalue Path

就是找树上最长的路径，使得这条路径上的权值都是一样。

这个题的关键在于抓住这样的特点，所有的树根的值都是由左子树可以求出的值加上右子树加上的值，然后子树的值是由左子树和子树的较大值来决定的。具体可参见下图。树根的26是可以由左子树和右子树的值相加，但是子树却不行，因为子树再选取和的话就无法构成书树上的路径了。
    
![](https://i.loli.net/2017/10/02/59d1a24b93812.jpg)    
    
理解了这一点，就不会把上图的答案算成5了。这个图的答案应该是4.

**思路1： 和之前做遍历的那个值做比较，如果不相等就代表不是一个序列下来的，否则就是同一颜色。**

**思路2：  每次都以每个点为根做一次，那么此时就很简单，判断子树有多少是和根的值是一样的就好了。**

## C.Knight Probability in Chessboard

也许是第一次比赛中做对的概率DP。比较简单的三维。如果能从(i, j)跳到(i',j')，就把(i',j')跳的概率加上(i,j)跳的概率/8。因此可以得到概率转移方程。 

## D.Maximum Sum of 3 Non-Overlapping Subarrays

大意基本上如题目的标题。求最大的3个元素数是k的子集的和。n<=2e4

关注中间这个子集。如果中间这个子集是在[i,i+k-1], 那么左边的这个子集就在[0,i-1],右边的就在[i+k, n-1],然后求出左边的最大的子集和与右边最大的。具体这么求，扫一遍就好了，因为后面的只会是前面的最大或者就是这个元素。O(n)。手写推一下就行。具体可见代码。
 



