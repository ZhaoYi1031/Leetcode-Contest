# Leetcode-Contest-95
    
[题目传送门](https://leetcode.com/contest/weekly-contest-95/)

第一题水题，第二题是个假博弈题，第三题是不错的数轮题，第四题是个背包。没来的及写完最后一题。

## B

题目的大意就是A和B两人玩游戏，轮流从一个序列取数字，其中两人都只能选择最边上的数字，A先取，现在问A是否能够获胜。序列的长度为偶数，且序列的总和是奇数。

最后给的那个序列长度为偶数是一个非常有用的条件。我们可以考虑最简单的两种取法。一个是只取下标是偶数的，一种是只取下标是奇数的。怎么做到呢？非常easy。（假如我们的序列是以0开始的）比如都是偶数，即第一次取的数是第一个，之后都贴着B取就行了；对于都是奇数的，则第一次取最后一个，之后类似。然后这两种方法哪个大都选哪个，因此A必胜，直接`return true`就ok了。

我们想一下没有这个偶数这个条件，应该怎么做呢？

用f[i][j]表示在[i,j]这个区间里你可以比竞争者选取的多出来的总和。然后递推公式为：

1. 选择a[i]，则f[i][j] = a[i] - f[i+1][j]
2. 选择a[j], 则f[i][j] = a[j] - f[i][j-1]

所以f[i][j] = max(a[i] - f[i+1][j], a[j] - f[i][j-1])

最后判断f[1][n]是否>0即可。

## C

问第n个可以被A或者B整除的数是多个。

对于h=LCM(A,B)这一段区间，我们可以看到每一个区间都有h/A+h/B-1个数。然后我的做法就是除掉这一段区间，然后在取模的小区间内计算出来加上之前的那个总的。

也可以用二分来写。因为我们知道对于小于x的数有x/A+x/B-lcm个答案，直接二分结果。

哦对了，对于去除vector里的重复元素的方法是`v.erase(unique(v.begin(), v.end()), v.end());`, 一开始漏了最后的v.end()，相当于只删了那个重复开始的第一个元素。


## D.

有一堆组，每个组有人数和利润。我们要从中选取一些组，使得这些组的利润和>=P，且人数<=G，问有多少组。范围都是100.

像一个变种的背包。我的思路就是用f[i][j][k]表示前i个背包使得人数为j、利润为k的个数。转移方程：f[i][j][k] += f[i-1][j-group[i]][k-profit[i]]，其中每一个f[i][j][k]的初始值为f[i-1][j][k]. 最后统计所有的f[N][0..G][P..max]然后对于第一维需要滚动一下。时间复杂度O(nmk), 空间复杂度是O(mkl), 其中l是每一个利润的范围。

在讨论区看到的另外的做法，略有区别，因为空间复杂度更小。

用dp[i][j]表示有i个利润和j个成员的个数（注意到后面为了能够减维，将>=P的都并到了一起）

状态转移方程为：

dp[i+p][j+g] += dp[i][j] if i+p < P
dp[P][j+g] += dp[i][j] if i+p >= P

最后统计所有dp[P]的和。时间复杂度是一样的，空间复杂度是O(mk)。

