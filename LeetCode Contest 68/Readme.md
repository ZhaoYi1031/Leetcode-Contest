# Leetcode-Contest-68
    
[题目传送门](https://leetcode.com/contest/weekly-contest-68/)

几周没做LeetCode，这周Leetcode把C题拆分成两个部分，第一个部分是比较小的数据，第二个题也就是D题是范围大的数据。原来的D题挪到了E题。所以一开始想的C题的算法有问题我就直接写了一个暴力过了C，当写完B之后D算法想出来了却没来得及写，有点亏了。应该是直接想出C和D的标解，因为LeetCode的题比GCJ简单的多，我们不需要通过先过小数据去发现规律这样的方式。

## A. Toeplitz Matrix

水题。从左上到右下方向的对角线的值都相等。直接遍历每个元素，判断a[i][j]是否等于a[i+1][j+1]

## B. Reorganize String

题意是给你一个包含小写字母的字符串，判断能不能通过交换相邻的字母使得最终任意两个相邻的字母都不一样。如果可以，求出最后交换后的字符串。
    
首先，我们能很容易地判断出来交换相邻的字母是可以形成这些字符的全排列的（每一个字符都可以交换到任意的位置）,所以我们很容易判断能够交换到所要求的字符串。即每个字符的出现次数都不能过半，即大于(n+1)/2.

然后我们怎么形成最终的字符串呢？我的做法是从出现次数多的到少的逐一开始填，除了第一个字符串是直接填充之外，之后的每个字符都是隔一个去填原来的字符串。看了讨论区的做法，还有的做法就是：将排好序（例如aaaabbc）的字符串，分成两部分，然后设置两个指针，一个从前面开始，一个从中间开始，往结果的字符串序列去插入。

## C.Max Chunks to Make Sorted

题意就是把一个序列分成尽量多的子序列，使得每个子序列排序后拼起来仍然有序。例如[2,1,3,4,4]可以分成[2, 1], [3], [4], [4] 再合起来形成[1,2,3,4,4]这种最终有序的序列。

小的样例随便怎么搞都行。O(n)的算法如下：

**当左边序列的最大值比右边序列的最小值要小(可以等)时，我们是可以在这个节点划分的。然后右边的子序列同样处理**



代码如下：

```
int maxChunksToSorted(vector<int>& arr) {
   int ans = 0;
   int maxi = -1;
   int n = arr.size();
   mi[n] = 1e9;
   rep2 (i,n-1,0)
       mi[i] = min(arr[i], mi[i+1]);
   
   mx = arr[0];
   rep (i,0,n-1){
       if (i == n-1 || mx <= mi[i+1]){
           ans++;
           if (i != n-1)
               mx = arr[i+1];
       }else{
           if (i != n-1)
               mx = max(mx, arr[i+1]);
       }
   }
   return ans;
}
```

在网上看到另一种用multiset（用multiset是因为序列中可能有重复的数字）写的非常简便的做法：我们把原序列记做a，把原序列排好序叫做b，然后a和b同时往两个multiset插入。每当这两个multiset相等的时候我们就把结果+1。非常机制的做法。




